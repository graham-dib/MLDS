---
title: \normalsize Assessment 3 \hfill MATH70094 Programming for Data Science \hfill Autumn 2025
    \rule{\linewidth}{0.5mm}
output:
  html_document: default
  pdf_document: default
editor_options:
  markdown:
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Enter NAME and CID here


# Question 2 (45 marks)

**The only non-base-R package you are allowed to load in this question is testthat.**

Given a time series of length $n$ with data $y_1,\dots,y_n\in\mathbb{R}$, we want to compare different ways for forecasting future values $y_{k}$ of the time series at times $k>n$. Depending on what statistical model we think has generated the data, a different forecasting method is appropriate. Here, we consider two statistical models: 

(1) The time series was generated by $y_k = \epsilon_k$, where the $\epsilon_k$ are independent centred random variables. In this case, the time series has no trend and has expectation zero at all times.  
(2) The time series is an 'autoregressive process of order 1', where $y_{k+1} = \phi y_k + \epsilon_k$ for $k\in\mathbb{N}$ with a scalar $\phi$ and independent standard Gaussian random variables $\epsilon_k$ (more general autoregressive processes can be defined). The value of $\phi$ decides how the time series evolves over time. 

Relative to the two models, we forecast future values of the time series as follows:

(1) Using the rolling mean: Given a window length $h\in\mathbb{N}$, compute the 'rolling mean' $\bar{y}_h = h^{-1}(y_{n-h+1} + y_{n-h+2} + \dots + y_n)$. The predicted value of the time series at time $k>n$ is $\bar{y}_h$ for any $k$.
(2) The parameter $\phi$ can be estimated by $\hat{\phi} = \frac{\sum_{k=2}^n y_{k-1} y_k}{\sum_{k=2}^n (y_{k-1})^2}$. The predicted value of the time series at time $n+1$ is $\hat y_{n+1} = \hat\phi y_n$, the value at $n+2$ is $\hat y_{n+2} = \hat\phi \hat y_{n+1}$ etc.

Your task in this question is to write three different S3 classes in R specified as follows:

1. A class `TimeSeriesModel` with two methods `forecast` and `plot_forecast`. The two methods have no implementations, but both take as argument an integer `window_prediction_length` to indicate the number of future time steps that should be forecast. This class serves as a common parent class for the subclasses `RollingMeanModel` and `AR1Model` below. The constructor should not do anything as we will never instantiate objects from this class, so you can just use
```{r}
TimeSeriesModel <- function() {
  # TimeSeriesModel is abstract so use a subclass
}
```
2. A subclass `RollingMeanModel` of `TimeSeriesModel` with
  - a constructor method that instantiates an object of `RollingMeanModel` given a time series (a `ts` object, check `?ts`) and an integer argument `window_train_length`; the latter is used to set the attribute `window_mean` that records the average value of the time series over the last `window_train_length` values,
  - a forecast method that overrides the forecast method from `TimeSeriesModel` and predicts the value of the time series for `window_prediction_length` future steps by `window_mean`,
  - a plot method `plot_forecast` that plots the time series model using the `plot.ts` function as well as the values of a 5-step prediction in the same graph.
3. A subclass `AR1Model` of `TimeSeriesModel` with 
  - a constructor method that instantiates an object of `AR1Model` given a time series; an object is instantiated by estimating the phi coefficient using the estimator $\hat\phi$ from above; the estimator is used to set an attribute of the same name,
  - a forecast method that overrides the forecast method from `TimeSeriesModel` and predicts the value of the time series for `window_prediction_length` future steps as follows: at time one in the future the prediction is $\hat y_{n+1}=\hat\phi*y_{n}$ with $y_{n}$ the last value of the training data, at time two by $\hat y_{n+2}=\hat\phi*\hat y_{n+1}$, etc,
  - a plot method `plot_forecast` that plots the time series model using the `plot.ts` function as well as the values of a 5-step prediction.
  
Below, you will be asked to write and use these classes in a test driven development approach.

## Code clarity (3 mark)

There is a famous saying among software developers that code is read
more often than it is written. Marks will be awarded (or not awarded)
based on the clarity of the code and appropriate use of comments.

## Part A (10 marks)

Provide an interface (only class names, method names and empty method bodies, S3-generics) for the three classes as specified above. Every class and every method should have a short comment describing the expected functionality. Do not provide implementations for the methods.

```{r}
# write the interfaces here

```

## Part B (10 marks)

Use the `testthat` library (you may have to install it first) to write two test functions with `test_that` to test if your class codes work as expected:

1. For use during testing, create a time series object by defining a vector repeating the value 1 for 50 times and applying the `ts` function. Generate from this a `RollingMeanModel` object with `window_train_length` equal to 5, and an `AR1Model` object. 
2. A test function that checks if the models have been constructed correctly. There is some flexibility here. You could test for example if the internal variables have been set properly. 
3. A test function that checks if the model predictions have the correct length (as specified by `window_prediction_length`).

All tests should \emph{fail} at this point. Include `error=TRUE` in the RMarkdown cell to prevent failing tests from stopping code execution.

```{r, error=TRUE}
library(testthat)

# add your solution here
```

## Part C (10 marks)

Provide implementations for the three classes from part A. All tests from part B should now pass without errors or failures.

```{r}
# add your solution here

```

## Part D (12 marks)

### Part D(i) (8 marks)

Add a function `compare_models` (not part of any class) that takes as arguments a time series `train`, a time series `test` and a `window_train_length`. Within the function, instantiate from the `train` time series a `RollingMeanModel` object and an `AR1Model` object. The `compare_models` function should then return TRUE if the mean square error between `test` and the forecast of the same length by the `RollingMeanModel` object is smaller than the mean square error between `test` and the forecast of the same length by the `AR1Model` object. 

Write also a test function (again using `test_that`) that checks if the `compare_models` function works as expected (and ideally write the test method first). The test should pass.

```{r}
# add your solution here

```

### Part D(ii) (4 marks)

Read in the data from the file `time_series_data.csv`. Split this data into two data sets and create two time series objects `train` and `test` using the `ts` function, where `train` consists of the first 150 data points and `test` of the remaining data. Using the `compare_models` functions from Part D(i), which model (out of `RollingMeanModel` and `AR1Model`) performs better in terms of forecasting for this data set?

```{r}
# add your solution here
```




