airlines <- read.csv("airlines.csv", stringsAsFactors = TRUE)
airports <- read.csv("airports.csv", stringsAsFactors = TRUE)
planes <- read.csv("planes.csv", stringsAsFactors = TRUE)
head(flights,5)
head(airlines,5)
head(airports,5)
head(planes,5)
print("The missing entries in each column in flights are")
n_nas <- colSums(is.na(flights))
n_nas
flights_birthday <- subset(flights, month == 2 & day == 11)
mean_arr_delay_on_birthday <- mean(flights_birthday$arr_delay, na.rm=TRUE)
print(paste0("The average delay on my birthday is ", round(mean_arr_delay_on_birthday,0), " minutes."))
flights_airlines <- merge(flights, airlines, by = "carrier")
colnames(flights_airlines)[colnames(flights_airlines) == "name"] <- "carrier_name"
# note: merge has different options for joining two dataframes, check with ?merge. not all airport shortnames are contained in airports datamframe! so we need to add all.x to include also those flights when merging.
flights_airlines_airports <- merge(flights_airlines, airports, by.x = "dest", by.y = "faa", all.x = TRUE)
colnames(flights_airlines_airports)[colnames(flights_airlines_airports) == "name"] <- "dest_name"
# check result
head(flights_airlines_airports)
# note: all flight in this dataset depart from New York City (check ?flights)
print("The number of unique airlines operating from New York City is ")
num_unique_airlines_from_nyc <- length(unique(flights$carrier))
num_unique_airlines_from_nyc
print("The number of unique airlines flying to Los Angeles Intl is ")
flights_to_LAX <- flights_airlines_airports[flights_airlines_airports$dest_name == "Los Angeles Intl",]
num_unique_airlines_to_lax <- length(unique(flights_to_LAX$carrier))
num_unique_airlines_to_lax
# aggregate the arrival delays by carrier_name, and apply to the groups (per carrier) the mean and median functions
agg <- aggregate(
cbind(arr_delay) ~ carrier_name,
data = flights_airlines_airports,
FUN = function(x) c(mean = mean(x, na.rm = TRUE), median = median(x, na.rm=TRUE))
)
# the resulting data.frame has a funny structure (check agg[1] and agg[2]), effectively returning two dataframes. to combine them use the do.call method
agg <- do.call(data.frame, agg)
names(agg)[2:3] <- c("mean_arr_delay", "median_arr_delay")
# add flight counts
counts <- as.data.frame(table(flights_airlines_airports$carrier_name))
names(counts) <- c("carrier_name", "n_flights")
# merge and sort
delays <- merge(agg, counts, by = "carrier_name")
delasy <- delays[order(delays$mean_arr_delay, decreasing=TRUE), ]
# check
head(delays)
print(paste0("The airline with the lowest mean arrival delay is ", delays[which.min(delays$mean_arr_delay),]$carrier_name))
print(paste0("The airline with the most flights is ", delays[which.max(delays$n_flights),]$carrier_name))
barplot(median_arr_delay ~ carrier_name, data = delays, las = 2, col = rgb(1,0,0,0.5), main = "Average Arrival Delay by Airline", ylab = "Average Delay (minutes)")
barplot(mean_arr_delay ~ carrier_name, data = delays, las = 2, col = rgb(0,0,1,0.5), main = "Average Arrival Delay by Airline", ylab = "Average Delay (minutes)")
# We notice that the median arrival delays are much lower (mostly negative) compared to the mean arrival delays. The reason is that there are some flights with much larger arrival delays than the majority, which is picked up by the mean but not by the median, as the mean is sensitive to large values.
print("The full names of the busiest desintation airports for each carrier are")
flight_table <- table(flights_airlines_airports$carrier, flights_airlines_airports$dest_name)
busiest_dest_per_carrier <- apply(flight_table, 1, function(x) names(x)[which.max(x)])
busiest_dest_per_carrier
# first define a helper function to turn time in HHMM format to minutes
hhmm_to_minutes <- function(x) {
hr <- x %/% 100
min <- x %% 100
hr*60 + min
}
# compute the scheduled and actual durations
sched_dep <- hhmm_to_minutes(flights$sched_dep_time)
sched_arr <- hhmm_to_minutes(flights$sched_arr_time)
dep <- hhmm_to_minutes(flights$dep_time)
arr <- hhmm_to_minutes(flights$arr_time)
sched_dur <- sched_arr - sched_dep
sched_dur[sched_dur < 0] <- sched_dur[sched_dur < 0] + 24*60 # account for overnight flights
actual_dur <- arr - dep
actual_dur[!is.na(actual_dur) & actual_dur < 0] <- actual_dur[!is.na(actual_dur) & actual_dur < 0] + 24*60 # overnight flights
flights$sched_dur <- sched_dur
flights$actual_dur <- actual_dur
flights$efficiency <- flights$sched_dur / flights$actual_dur
flights_planes <- merge(flights, planes[, c("tailnum","manufacturer")], by="tailnum")
# using merge this way automatically avoids rows from the first dataframe (flights) where the manufacturer cannot be identified according to the merge column (tailnum)
top_efficient <- flights_planes[order(flights_planes$efficiency, decreasing=TRUE), c("manufacturer")]
print(paste("The unique manufacturers of the 100 most efficient flights are ", toString(unique(head(top_efficient, 100)))))
print(paste("The unique manufacturers of the 100 least efficient flights are", toString(unique(tail(top_efficient, 100)))))
knitr::opts_chunk$set(echo = TRUE)
# Predicts the value of the time series at window_prediction_length future time points.
forecast <- function(model, window_prediction_length) {
UseMethod("forecast")
}
# Plots the time series model using the plot.ts function and a 5-step prediction.
plot_forecast <- function(model, window_prediction_length=5){
UseMethod("plot_forecast")
}
TimeSeriesModel <- function() {
stop("TimeSeriesModel is abstract. Use a subclass.")
}
# RollingMeanModel interface
# A RollingMeanModel inherits from TimeSeriesModel. An object is instantiated by taking a time series and a window length to set an attribute that records the average value of the time series over the window.
RollingMeanModel <- function(time_series_data, window_train_length) {
structure(
list(
time_series_data = numeric(),
window_mean = numeric()
),
class = c("RollingMeanModel", "TimeSeriesModel")
)
}
# Predicts the value of the time series given the average value of the time series given the average value computed at instantiation.
forecast.RollingMeanModel <- function(model, window_prediction_length) {
return(numeric())
}
# Plots the time series model using the plot.ts function and a 5-step prediction.
plot_forecast.RollingMeanModel <- function(model, window_prediction_length=5) {
}
# AR1Model interface
# An AR1Model inherits from TimeSeriesModel. An object is instantiated by taking a time series and setting an attribute that corresponds to the phi coefficient in an AR1 representation.
AR1Model <- function(time_series_data) {
structure(
list(
time_series_data = NULL,
phi = NULL
),
class = c("AR1Model", "TimeSeriesModel")
)
}
# Predicts the value of the time series: at time one in the future the prediction is $\hat y_{n+1}=phi*y_{n}$ with $y_{n}$ the last value of the training data, at time two by $\hat y_{n+2}=phi*\hat y_{n+1}$, etc.
forecast.AR1Model <- function(model, window_prediction_length) {
}
# Plots the time series model using the plot.ts function and a 5-step prediction.
plot_forecast.AR1Model <- function(model, window_prediction_length=5) {
}
library(testthat)
# examples used during testing
ts_data <- rep(1,50)
rm_window_train_length <- 5
model_rm <- RollingMeanModel(ts_data, rm_window_train_length)
model_ar <- AR1Model(ts_data)
test_that("Models construct correctly", {
expect_equal(ts_data, model_rm$time_series_data)
expect_equal(model_rm$window_mean, 1)
expect_equal(ts_data, model_ar$time_series_data)
expect_true(!is.na(model_ar$phi))
})
test_that("Models forecast correct length", {
preds_rm <- forecast(model_rm,5)
preds_ar <- forecast(model_ar,5)
expect_length(preds_rm, 5)
expect_length(preds_ar, 5)
})
# RollingMeanModel implementation
# A RollingMeanModel inherits from TimeSeriesModel. An object is instantiated by taking a time series and a window length to set an attribute that records the average value of the time series over the window.
RollingMeanModel <- function(time_series_data, window_train_length) {
# Private fit function
fit <- function(time_series_data, window_train_length) {
return(mean(tail(time_series_data, window_train_length)))
}
structure(
list(
time_series_data = time_series_data,
window_mean = fit(time_series_data, window_train_length)
),
class = c("RollingMeanModel", "TimeSeriesModel")
)
}
# Predicts the value of the time series given the average value of the time series given the average value computed at instantiation.
forecast.RollingMeanModel <- function(model, window_prediction_length) {
rep(model$window_mean, window_prediction_length)
}
# Plots the time series model using the plot.ts function and a 5-step prediction.
plot_forecast.RollingMeanModel <- function(model, window_prediction_length=5) {
preds <- forecast(model, window_prediction_length)
ts_full <- c(model$time_series_data, preds)
plot(ts_full, type="l", main="Rolling Mean Forecast",
xlab="Time", ylab="Value")
abline(v = length(model$time_series_data), lty = 2)
}
# AR1Model implementation
# An AR1Model inherits from TimeSeriesModel. An object is instantiated by taking a time series and setting an attribute that corresponds to the phi coefficient in an AR1 representation.
AR1Model <- function(time_series_data) {
# Private fit function
fit <- function(y) {
y_lag <- head(y, -1)
y_curr <- tail(y, -1)
phi <- sum(y_lag * y_curr) / sum(y_lag^2)
return(phi)
}
structure(
list(
time_series_data = time_series_data,
phi = fit(time_series_data)
),
class = c("AR1Model", "TimeSeriesModel")
)
}
# Predicts the value of the time series: at time one in the future the prediction is $\hat y_{n+1}=phi*y_{n}$ with $y_{n}$ the last value of the training data, at time two by $\hat y_{n+2}=phi*\hat y_{n+1}$, etc.
forecast.AR1Model <- function(model, window_prediction_length) {
preds <- numeric(window_prediction_length)
preds[1] <- model$phi * tail(model$time_series_data, 1)
if (window_prediction_length > 1) {
for (i in 2:window_prediction_length) preds[i] <- model$phi * preds[i-1]
}
return(preds)
}
# Plots the time series model using the plot.ts function and a 5-step prediction.
plot_forecast.AR1Model <- function(model, window_prediction_length=5) {
preds <- forecast(model, window_prediction_length)
ts_full <- c(model$time_series_data, preds)
plot(ts_full, type="l", main="AR(1) Forecast",
xlab="Time", ylab="Value")
abline(v = length(model$time_series_data), lty = 2)
}
library(testthat)
# examples used during testing
ts_data <- rep(1,50)
rm_window_train_length <- 5
model_rm <- RollingMeanModel(ts_data, rm_window_train_length)
model_ar <- AR1Model(ts_data)
test_that("Models construct correctly", {
expect_equal(ts_data, model_rm$time_series_data)
expect_equal(model_rm$window_mean, 1)
expect_equal(ts_data, model_ar$time_series_data)
expect_true(!is.na(model_ar$phi))
})
test_that("Models forecast correct length", {
preds_rm <- forecast(model_rm,5)
preds_ar <- forecast(model_ar,5)
expect_length(preds_rm, 5)
expect_length(preds_ar, 5)
})
test_that("Model comparison works", {
train <- head(ts_ex1, 40)
test <- tail(ts_ex1, 10)
expect_true(compare_models(train,test,10))
})
# Compares RollingMeanModel and AR1Model training from training datat by comparing prediction errors along test data. Returns TRUE if RollingMeanModel has smaller error, otherwise returns FALSE.
compare_models <- function(train, test, window_train_length) {
rm_model <- RollingMeanModel(train, window_train_length)
ar_model <- AR1Model(train)
rm_preds <- forecast(rm_model, length(test))
ar_preds <- forecast(ar_model, length(test))
rm_err <- mean((test - rm_preds)^2)
ar_err <- mean((test - ar_preds)^2)
cat("Rolling Mean MSE:", rm_err, "\n")
cat("AR(1) MSE:", ar_err, "\n")
return(rm_err < ar_err)
}
test_that("Model comparison works", {
train <- head(ts_ex1, 40)
test <- tail(ts_ex1, 10)
expect_true(compare_models(train,test,10))
})
# Compares RollingMeanModel and AR1Model training from training datat by comparing prediction errors along test data. Returns TRUE if RollingMeanModel has smaller error, otherwise returns FALSE.
compare_models <- function(train, test, window_train_length) {
rm_model <- RollingMeanModel(train, window_train_length)
ar_model <- AR1Model(train)
rm_preds <- forecast(rm_model, length(test))
ar_preds <- forecast(ar_model, length(test))
rm_err <- mean((test - rm_preds)^2)
ar_err <- mean((test - ar_preds)^2)
cat("Rolling Mean MSE:", rm_err, "\n")
cat("AR(1) MSE:", ar_err, "\n")
return(rm_err < ar_err)
}
test_that("Model comparison works", {
train <- head(ts_data, 40)
test <- tail(ts_data, 10)
expect_true(compare_models(train,test,10))
})
y <- read.csv("time_series_data.csv")$x
train <- head(y, 150)
test  <- tail(y, 50)
compare_models(train, test, window_train_length = 10)
print("The AR1Model performs better than the rolling mean in terms of mean square prediction error.")
# Compares RollingMeanModel and AR1Model training from training datat by comparing prediction errors along test data. Returns TRUE if RollingMeanModel has smaller error, otherwise returns FALSE.
compare_models <- function(train, test, window_train_length) {
rm_model <- RollingMeanModel(train, window_train_length)
ar_model <- AR1Model(train)
rm_preds <- forecast(rm_model, length(test))
ar_preds <- forecast(ar_model, length(test))
rm_err <- mean((test - rm_preds)^2)
ar_err <- mean((test - ar_preds)^2)
cat("Rolling Mean MSE:", rm_err, "\n")
cat("AR(1) MSE:", ar_err, "\n")
return(rm_err < ar_err)
}
test_that("Model comparison works", {
train <- head(ts_data, 40)
test <- tail(ts_data, 10)
expect_true(compare_models(train,test,10))
})
# Compares RollingMeanModel and AR1Model training from training datat by comparing prediction errors along test data. Returns TRUE if RollingMeanModel has smaller error, otherwise returns FALSE.
compare_models <- function(train, test, window_train_length) {
rm_model <- RollingMeanModel(train, window_train_length)
ar_model <- AR1Model(train)
rm_preds <- forecast(rm_model, length(test))
ar_preds <- forecast(ar_model, length(test))
rm_err <- mean((test - rm_preds)^2)
ar_err <- mean((test - ar_preds)^2)
print(ar_model$phi)
cat("Rolling Mean MSE:", rm_err, "\n")
cat("AR(1) MSE:", ar_err, "\n")
return(rm_err < ar_err)
}
test_that("Model comparison works", {
train <- head(ts_data, 40)
test <- tail(ts_data, 10)
expect_true(compare_models(train,test,10))
})
library(testthat)
# examples used during testing
ts_data <- rep(1,50)
rm_window_train_length <- 5
model_rm <- RollingMeanModel(ts_data, rm_window_train_length)
model_ar <- AR1Model(ts_data)
test_that("Models construct correctly", {
expect_equal(ts_data, model_rm$time_series_data)
expect_equal(model_rm$window_mean, 1)
expect_equal(ts_data, model_ar$time_series_data)
expect_true(!is.na(model_ar$phi))
})
test_that("Models forecast correct length", {
preds_rm <- forecast(model_rm,5)
preds_ar <- forecast(model_ar,5)
expect_length(preds_rm, 5)
expect_length(preds_ar, 5)
})
# Compares RollingMeanModel and AR1Model training from training datat by comparing prediction errors along test data. Returns TRUE if RollingMeanModel has smaller error, otherwise returns FALSE.
compare_models <- function(train, test, window_train_length) {
rm_model <- RollingMeanModel(train, window_train_length)
ar_model <- AR1Model(train)
rm_preds <- forecast(rm_model, length(test))
ar_preds <- forecast(ar_model, length(test))
rm_err <- mean((test - rm_preds)^2)
ar_err <- mean((test - ar_preds)^2)
print(ar_model$phi)
cat("Rolling Mean MSE:", rm_err, "\n")
cat("AR(1) MSE:", ar_err, "\n")
return(rm_err < ar_err)
}
test_that("Model comparison works", {
train <- head(ts_data, 40)
test <- tail(ts_data, 10)
# in this case both model forecasts coincide!
expect_false(compare_models(train,test,10))
})
# Predicts the value of the time series at window_prediction_length future time points.
forecast <- function(model, window_prediction_length) {
UseMethod("forecast")
}
# Plots the time series model using the plot.ts function and a 5-step prediction.
plot_forecast <- function(model, window_prediction_length=5){
UseMethod("plot_forecast")
}
TimeSeriesModel <- function() {
# TimeSeriesModel is abstract so use a subclass; alternatively, we could use 'stop' to throw an error
}
# RollingMeanModel interface
# A RollingMeanModel inherits from TimeSeriesModel. An object is instantiated by taking a time series and a window length to set an attribute that records the average value of the time series over the window.
RollingMeanModel <- function(time_series_data, window_train_length) {
structure(
list(
time_series_data = numeric(),
window_mean = numeric()
),
class = c("RollingMeanModel", "TimeSeriesModel")
)
}
# Predicts the value of the time series given the average value of the time series given the average value computed at instantiation.
forecast.RollingMeanModel <- function(model, window_prediction_length) {
return(numeric())
}
# Plots the time series model using the plot.ts function and a 5-step prediction.
plot_forecast.RollingMeanModel <- function(model, window_prediction_length=5) {
}
# AR1Model interface
# An AR1Model inherits from TimeSeriesModel. An object is instantiated by taking a time series and setting an attribute that corresponds to the phi coefficient in an AR1 representation.
AR1Model <- function(time_series_data) {
structure(
list(
time_series_data = NULL,
phi = NULL
),
class = c("AR1Model", "TimeSeriesModel")
)
}
# Predicts the value of the time series: at time one in the future the prediction is $\hat y_{n+1}=phi*y_{n}$ with $y_{n}$ the last value of the training data, at time two by $\hat y_{n+2}=phi*\hat y_{n+1}$, etc.
forecast.AR1Model <- function(model, window_prediction_length) {
}
# Plots the time series model using the plot.ts function and a 5-step prediction.
plot_forecast.AR1Model <- function(model, window_prediction_length=5) {
}
library(testthat)
# examples used during testing
ts_data <- rep(1,50)
rm_window_train_length <- 5
model_rm <- RollingMeanModel(ts_data, rm_window_train_length)
model_ar <- AR1Model(ts_data)
test_that("Models construct correctly", {
expect_equal(ts_data, model_rm$time_series_data)
expect_equal(model_rm$window_mean, 1)
expect_equal(ts_data, model_ar$time_series_data)
expect_true(!is.na(model_ar$phi))
})
test_that("Models forecast correct length", {
preds_rm <- forecast(model_rm,5)
preds_ar <- forecast(model_ar,5)
expect_length(preds_rm, 5)
expect_length(preds_ar, 5)
})
# RollingMeanModel implementation
# A RollingMeanModel inherits from TimeSeriesModel. An object is instantiated by taking a time series and a window length to set an attribute that records the average value of the time series over the window.
RollingMeanModel <- function(time_series_data, window_train_length) {
# Private fit function
fit <- function(time_series_data, window_train_length) {
return(mean(tail(time_series_data, window_train_length)))
}
structure(
list(
time_series_data = time_series_data,
window_mean = fit(time_series_data, window_train_length)
),
class = c("RollingMeanModel", "TimeSeriesModel")
)
}
# Predicts the value of the time series given the average value of the time series given the average value computed at instantiation.
forecast.RollingMeanModel <- function(model, window_prediction_length) {
rep(model$window_mean, window_prediction_length)
}
# Plots the time series model using the plot.ts function and a 5-step prediction.
plot_forecast.RollingMeanModel <- function(model, window_prediction_length=5) {
preds <- forecast(model, window_prediction_length)
ts_full <- c(model$time_series_data, preds)
plot(ts_full, type="l", main="Rolling Mean Forecast",
xlab="Time", ylab="Value")
abline(v = length(model$time_series_data), lty = 2)
}
# AR1Model implementation
# An AR1Model inherits from TimeSeriesModel. An object is instantiated by taking a time series and setting an attribute that corresponds to the phi coefficient in an AR1 representation.
AR1Model <- function(time_series_data) {
# Private fit function
fit <- function(y) {
y_lag <- head(y, -1)
y_curr <- tail(y, -1)
phi <- sum(y_lag * y_curr) / sum(y_lag^2)
return(phi)
}
structure(
list(
time_series_data = time_series_data,
phi = fit(time_series_data)
),
class = c("AR1Model", "TimeSeriesModel")
)
}
# Predicts the value of the time series: at time one in the future the prediction is $\hat y_{n+1}=phi*y_{n}$ with $y_{n}$ the last value of the training data, at time two by $\hat y_{n+2}=phi*\hat y_{n+1}$, etc.
forecast.AR1Model <- function(model, window_prediction_length) {
preds <- numeric(window_prediction_length)
preds[1] <- model$phi * tail(model$time_series_data, 1)
if (window_prediction_length > 1) {
for (i in 2:window_prediction_length) preds[i] <- model$phi * preds[i-1]
}
return(preds)
}
# Plots the time series model using the plot.ts function and a 5-step prediction.
plot_forecast.AR1Model <- function(model, window_prediction_length=5) {
preds <- forecast(model, window_prediction_length)
ts_full <- c(model$time_series_data, preds)
plot(ts_full, type="l", main="AR(1) Forecast",
xlab="Time", ylab="Value")
abline(v = length(model$time_series_data), lty = 2)
}
# Compares RollingMeanModel and AR1Model training from training datat by comparing prediction errors along test data. Returns TRUE if RollingMeanModel has smaller error, otherwise returns FALSE.
compare_models <- function(train, test, window_train_length) {
rm_model <- RollingMeanModel(train, window_train_length)
ar_model <- AR1Model(train)
rm_preds <- forecast(rm_model, length(test))
ar_preds <- forecast(ar_model, length(test))
rm_err <- mean((test - rm_preds)^2)
ar_err <- mean((test - ar_preds)^2)
print(ar_model$phi)
cat("Rolling Mean MSE:", rm_err, "\n")
cat("AR(1) MSE:", ar_err, "\n")
return(rm_err < ar_err)
}
test_that("Model comparison works", {
train <- head(ts_data, 40)
test <- tail(ts_data, 10)
# in this case both model forecasts coincide!
expect_false(compare_models(train,test,10))
})
y <- read.csv("time_series_data.csv")$x
train <- head(y, 150)
test  <- tail(y, 50)
compare_models(train, test, window_train_length = 10)
print("The AR1Model performs better than the rolling mean in terms of mean square prediction error.")
library(testthat)
# examples used during testing
ts_data <- rep(1,50)
rm_window_train_length <- 5
model_rm <- RollingMeanModel(ts_data, rm_window_train_length)
model_ar <- AR1Model(ts_data)
test_that("Models construct correctly", {
expect_equal(ts_data, model_rm$time_series_data)
expect_equal(model_rm$window_mean, 1)
expect_equal(ts_data, model_ar$time_series_data)
expect_true(!is.na(model_ar$phi))
})
test_that("Models forecast correct length", {
preds_rm <- forecast(model_rm,5)
preds_ar <- forecast(model_ar,5)
expect_length(preds_rm, 5)
expect_length(preds_ar, 5)
})
y <- ts(read.csv("time_series_data.csv")$x)
train <- head(y, 150)
test  <- tail(y, 50)
compare_models(train, test, window_train_length = 10)
print("The AR1Model performs better than the rolling mean in terms of mean square prediction error.")
train
